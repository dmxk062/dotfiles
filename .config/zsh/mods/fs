#!/bin/false
# vim: ft=zsh

# make filesystem naviation/file handling easier

if [[ "$1" == "load" ]] {

alias md="mkdir -p"

function mcd {
    if [[ -d "$1" ]] {
        cd "$1"
        return
    }
    mkdir -p "$1"
    cd "$1"
}

function mkf {
    local -a filenames=("$@")
    local i file no_ext
    for  ((i=1; i<=$#filenames;i++)) {
        file="${filenames[i]}"
        if [[ -f "$file" || -d "$file" ]] {
            print "File already exists: $file" > /dev/stderr
            continue
        }
        case "$file" in
            *\.c|*\.h)
                no_ext="${file%%.*}"
                if [[ "${filenames[i+1]}" =~ "$no_ext\.." ]] {
                    echo "#include \"$no_ext.h\"" > "$no_ext.c"
                    echo "#pragma once" > "$no_ext.h"
                    ((i++))
                }
                ;;
            main.c)
                echo "int main(int argc, char* argv[]) {\n    return 0;\n}" > "$file"
                ;;
            main.py)
                echo "def main():\n    pass\n\nif __name__ == \"__main__\":\n    main()" > "$file"
                ;;
            *\.sh)
                echo "#!/usr/bin/env bash" > "$file"
                chmod +x "$file"
                ;;
            *\.py)
                echo "#!/usr/bin/env python" > "$file"
                chmod +x "$file"
                ;;
            *)
                echo -n "" > "$file";;
        esac
    }
}

alias ft="file --mime-type -F$'\t'"
alias bft="file --brief --mime-type -N"


function find_containing {
    local search_term="$1"
    local search_path
    if [[ -z "$2" ]] {
        search_path="$PWD"
        shift 1
    } else {
        search_path="$2"
        shift 2
    }
    local flags="$@"

    rg --color=never --files-with-matches $flags "$search_term" "$search_path"
}

function tmp {
    local tmpdir="$HOME/Tmp"
    local mode
    local files
    local force=0
    case "$1" in
        rm|del)
            mode=delete
            shift
            ;;
        rmf)
            mode=delete
            force=1
            shift
            ;;
        cp|copy)
            mode=copy
            shift
            files=("${@:2}")
            ;;
        *)
            mode=cd
            ;;
    esac
    local target="${1}"

    case $mode in 
        cd)
            if [[ -d "$tmpdir/$target" ]] {
                cd "$tmpdir/$target"
                return
            } else {
                mkdir -p "$tmpdir/$target"
                cd "$tmpdir/$target"
            }
            ;;
        delete)
            if rmdir "$tmpdir/$target" &> /dev/null; then
                return
            elif [[ $force == 1 ]]; then
                \rm -rf "$tmpdir/$target"
                return
            fi
            print -P -- "%F{red}$target is not empty\nUse %B\`$0 rmf $target\`%f%b"
            return 1
            ;;
        copy)
            if ! [[ -d "$tmpdir/$target" ]] {
                mkdir -p "$tmpdir/$target"
            }
            cp --target-directory="$tmpdir/$target" "${files[@]}"
            return
            ;;
    esac

}

# better realpath
function rp {
    print -l -- "${@:A}"
}

function readfile {
    local arrayname="${1}"
    local filename="${2}"

    eval "IFS=$'\n' ${arrayname}=(\$(< "${filename}"))"
}

function readstream {
    local arrayname="${1}"
    local line  
    local -a buffer

    while read -r line; do
        buffer+=("$line")
    done

    eval "${arrayname}=("\${buffer}")"

}



} elif [[ "$1" == "unload" ]] {

unfunction find_containing mcd mkf tmp rp \
    readfile readstream

unalias md ft bft

}
