#!/bin/false
# vim: ft=zsh

# function patterns in zsh

if [[ "$1" == "load" ]]; then


# all of these work pretty much the same:
# argv will be set based on an element in either an array or a line in stdin, split based on IFS
# use "$*" if you want to access it all like one variable


function map {
    local expr="$1"; shift
    local arg

    if (($# == 0)); then
        while read -r arg; do
            argv=(${=arg})
            eval $expr
        done
    else
        for arg in $@; do
            argv=(${=arg})
            eval $expr
        done
    fi
}

# first param is a function name
function fmap {
    local func="$1"; shift
    if (($# == 0)); then
        while read -r arg; do
            eval "$func" $arg
        done
    else
        for arg in $@; do
            eval "$func" $arg
        done
    fi


}

# conditional map, basically tfilter|map
function cmap {
    local cmp="[[ $1 ]]" 
    local expr="$2" 
    shift 2
    local arg

    if (($# == 0)); then
        while read -r arg; do
            argv=(${=arg})
            if eval $cmp; then
                eval $expr
            fi

        done
    else
        for arg in $@; do
            argv=(${=arg})
            if eval $cmp; then
                eval $expr
            fi
        done
    fi
}

# syntax sugar, for e.g ${*:A} for realpath
function pmap {
    local expr="print -- $1"; shift
    map "$expr" "$@"
}

function cpmap {
    local cmp="$1"
    local expr="print -- $2"
    shift 2
    cmap "$cmp" "$expr" "$@"
}
#
# arithmetic map, useful for e.g. unit conversion
function amap {
    local math="print -- \$[ $1 ]"; shift
    local arg

    if (($# == 0)); then
        while read -r arg; do
            argv=(${=arg})
            eval $math
        done
    else
        for arg in $@; do
            argv=(${=arg})
            eval $math
        done
    fi
}

# slower than map with just `echo -n`, just here cause afold is nice
function fold {
    local expr="$1"; shift
    local arg
    local results=""

    if (($# == 0)); then
        while read -r arg; do
            argv=(${=arg})
            results+=$(eval $expr)
        done
    else
        for arg in $@; do
            argv=(${=arg})
            results+=$(eval $expr)
        done
    fi
    print -- $results
}

function pfold {
    local expr="print -- $1"; shift
    fold "$expr" "$@"
}

# accumulate the results of math expressions, kinda like amap|sum
function afold {
    local math="print -- \$[ $1 ]"; shift
    local arg
    local result=0
    local _res

    if (($# == 0)); then
        while read -r arg; do
            argv=(${=arg})
            _res=$(eval "$math")
            ((result+=_res))
        done
    else
        for arg in $@; do
            argv=(${=arg})
            _res=$(eval "$math")
            ((result+=_res))
        done
    fi
    print -- $result

}

# only return values for with $expr returns 0
function filter {
    local expr="$1"; shift
    local arg

    if (($# == 0)); then
        while read -r arg; do
            argv=(${=arg})
            if eval $expr; then
                print -- $arg
            fi
        done
    else
        for arg in $@; do
            argv=(${=arg})
            if eval $expr; then
                print -- $arg
            fi
        done
    fi
}

# takes in a function e.g
# fun isFile { [[ -f "$*" ]]}
# ffilter isFile *
function ffilter {
    local func="$1"; shift
    local arg

    if (($# == 0)); then
        while read -r arg; do
            if eval "$func" $arg; then
                print -- $arg
            fi
        done
    else
        for arg in $@; do
            if eval "$func" $arg; then
                print -- $arg
            fi
        done
    fi
}

# syntax sugar to use expressions like test or [[ ]]
# e.g. tfilter '-f "$*"' *
function tfilter {
    local expr="[[ $1 ]]"; shift
    local arg

    if (($# == 0)); then
        while read -r arg; do
            argv=(${=arg})
            if eval $expr; then
                print -- $arg
            fi
        done
    else
        for arg in "$@"; do
            argv=(${=arg})
            if eval $expr; then
                print -- $arg
            fi
        done
    fi
}

# count, faster than just afold '1' or amap 1|sum
function cnt {
    if (($# > 0)); then
        print -- "$#"
        return
    fi

    local counter=0
    while read _; do
        ((counter++))
    done
    print -- "$counter"
}

# join the result of a process to stdout
# e.g.
# pgrep zsh|sjoin pgrep bash
# to get all pids of both
function sjoin {
    local expr="$1"
    shift
    local elem
    while read -r elem; do
        print -- "$elem"
    done
    eval $expr "$@"
}

# split nicely, either expanded args or each line
function sep {
    local elem
    local line
    if (($# == 0)); then
        while read -rA line; do
            for elem in "${line[@]}"; do
                print -- $elem
            done
        done
    else
        for elem in "$@"; do
            print -- $elem
        done
    fi
}


# nicer to type
alias fn="function"
# lambda
alias '\\'="function"

# mainly for use in functions
alias ret="print --"

# not just functions, also aliases and exes
alias getdef="whence -f -x 4"



elif [[ "$1" == "unload" ]]; then

unfunction filter tfilter ffilter \
    afold fold pfold \
    amap map cmap pmap cpmap fmap \
    cnt sjoin sep

unalias fn '\\' ret getdef

fi
