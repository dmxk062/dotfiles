#!/usr/bin/env zsh

# function patterns in zsh

# only source this, never run
if ! [[ $ZSH_EVAL_CONTEXT =~ :file$ ]]; then
    print "Extension modules are not meant to be run. Use \`+mod fun\` instead"
    exit 1
fi

if [[ "$1" == "load" ]]; then

# do smth once for every item in an array.
# $1 will expand; all args > 1 can still be used
function map {
    local expr="$1"; shift
    local arg

    if (($# == 0)); then
        while read -r arg; do
            1=$arg
            eval $expr
        done
    else
        for arg in $@; do
            1=$arg
            eval $expr
        done
    fi
}

# *a*rithmetic map
function amap {
    local math="print -- \$[ $1 ]"; shift
    local arg

    if (($# == 0)); then
        while read -r arg; do
            1=$arg
            eval $math
        done
    else
        for arg in $@; do
            1=$arg
            eval $math
        done
    fi
}

function fold {
    local expr="$1"; shift
    local arg
    local results=()

    if (($# == 0)); then
        while read -r arg; do
            1=$arg
            results+=($(eval $expr))
        done
    else
        for arg in $@; do
            1=$arg
            results+=($(eval $expr))
        done
    fi
    print -- $results
}

# fold with math
function afold {
    local math="print -- \$[ $1 ]"; shift
    local arg
    local result=0
    local _res

    if (($# == 0)); then
        while read -r arg; do
            1=$arg
            _res=$(eval "$math")
            ((result+=_res))
        done
    else
        for arg in $@; do
            1=$arg
            _res=$(eval "$math")
            ((result+=_res))
        done
    fi
    print -- $result

}

function filter {
    local expr="$1"; shift
    local arg

    if (($# == 0)); then
        while read -r arg; do
            1=$arg
            if eval $expr; then
                print -- $arg
            fi
        done
    else
        for arg in $@; do
            1=$arg
            if eval $expr; then
                print -- $arg
            fi
        done
    fi
}

# filter using a `test` or `[[` like syntax
function tfilter {
    local expr="[[ $1 ]]"; shift
    local arg

    if (($# == 0)); then
        while read -r arg; do
            1=$arg
            if eval $expr; then
                print -- $arg
            fi
        done
    else
        IFS=
        for arg in $@; do
            1=$arg
            if eval $expr; then
                print -- $arg
            fi
        done
    fi
}


alias fn="function"

alias '\\'="function"

alias ret="print --"

elif [[ "$1" == "unload" ]]; then

unfunction filter tfilter afold fold amap map 

unalias fn '\\' ret

fi
