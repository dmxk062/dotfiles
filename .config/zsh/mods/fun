#!/usr/bin/env zsh

# function patterns in zsh

# only source this, never run
if ! [[ $ZSH_EVAL_CONTEXT =~ :file$ ]]; then
    print "Extension modules are not meant to be run. Use \`source fun\` instead"
    exit 1
fi

if [[ "$1" == "load" ]]; then

# do smth once for every item in an array.
# $1 will expand; all args > 1 can still be used
function map {
    local expr="$1"; shift
    local arg

    if (($# == 0)); then
        while read -r arg; do
            eval ${expr//\$1/$arg}
        done
    else
        for arg in $@; do
            eval ${expr//\$1/$arg}
        done
    fi
}

# *a*rithmetic map
function amap {
    local math="print -- \$[ $1 ]"; shift
    local arg

    if (($# == 0)); then
        while read -r arg; do
            eval ${math//\$1/$arg}
        done
    else
        for arg in $@; do
            eval ${math//\$1/$arg}
        done
    fi
}

function fold {
    local expr="$1"; shift
    local arg
    local results=()

    if (($# == 0)); then
        while read -r arg; do
            results+=($(eval ${expr//\$1/$arg}))
        done
    else
        for arg in $@; do
            results+=($(eval ${expr//\$1/$arg}))
        done
    fi
    print -- $results
}

# fold with math
function afold {
    local math="print -- \$[ $1 ]"; shift
    local arg
    local result=0
    local _res

    if (($# == 0)); then
        while read -r arg; do
            _res=$(eval "${math//\$1/$arg}")
            ((result+=_res))
        done
    else
        for arg in $@; do
            _res=$(eval "${math//\$1/$arg}")
            ((result+=_res))
        done
    fi
    print -- $result

}

function filter {
    local expr="$1"; shift
    local arg

    if (($# == 0)); then
        while read -r arg; do
            if eval ${expr//\$1/$arg}; then
                print -- $arg
            fi
        done
    else
        for arg in $@; do
            if eval ${expr//\$1/$arg}; then
                print -- $arg
            fi
        done
    fi
}

# filter using a `test` or `[[` like syntax
function tfilter {
    local expr="[[ $1 ]]"; shift
    local arg

    if (($# == 0)); then
        while read -r arg; do
            if eval ${expr//\$1/$arg}; then
                print -- $arg
            fi
        done
    else
        for arg in $@; do
            if eval ${expr//\$1/$arg}; then
                print -- $arg
            fi
        done
    fi
}

elif [[ "$1" == "unload" ]]; then

unfunction filter tfilter afold fold amap map

fi
