#!/bin/false
# vim: ft=zsh

# function patterns in zsh

if [[ "$1" == "load" ]]; then


# all of these work pretty much the same:
# argv will be set based on an element in either an array or a line in stdin, split based on IFS
# use "$*" if you want to access it all like one variable


function map {
    local expr="$1"; shift
    local arg

    if (($# == 0)); then
        while read -r arg; do
            argv=(${=arg})
            eval $expr
        done
    else
        for arg in $@; do
            argv=(${=arg})
            eval $expr
        done
    fi
}

# conditional map, basically tfilter|map
function cmap {
    local cmp="[[ $1 ]]" 
    local expr="$2" 
    shift 2
    local arg

    if (($# == 0)); then
        while read -r arg; do
            argv=(${=arg})
            if eval $cmp; then
                eval $expr
            fi

        done
    else
        for arg in $@; do
            argv=(${=arg})
            if eval $cmp; then
                eval $expr
            fi
        done
    fi
}

function pmap {
    local expr="print -- $1"; shift
    map "$expr" "$@"
}

function cpmap {
    local cmp="$1"
    local expr="print -- $2"
    shift 2
    cmap "$cmp" "$expr" "$@"
}
# *a*rithmetic map
function amap {
    local math="print -- \$[ $1 ]"; shift
    local arg

    if (($# == 0)); then
        while read -r arg; do
            argv=(${=arg})
            eval $math
        done
    else
        for arg in $@; do
            argv=(${=arg})
            eval $math
        done
    fi
}

function fold {
    local expr="$1"; shift
    local arg
    local results=()

    if (($# == 0)); then
        while read -r arg; do
            argv=(${=arg})
            results+=($(eval $expr))
        done
    else
        for arg in $@; do
            argv=(${=arg})
            results+=($(eval $expr))
        done
    fi
    print -- $results
}

# fold with math
function afold {
    local math="print -- \$[ $1 ]"; shift
    local arg
    local result=0
    local _res

    if (($# == 0)); then
        while read -r arg; do
            argv=(${=arg})
            _res=$(eval "$math")
            ((result+=_res))
        done
    else
        for arg in $@; do
            argv=(${=arg})
            _res=$(eval "$math")
            ((result+=_res))
        done
    fi
    print -- $result

}

function filter {
    local expr="$1"; shift
    local arg

    if (($# == 0)); then
        while read -r arg; do
            argv=(${=arg})
            if eval $expr; then
                print -- $arg
            fi
        done
    else
        for arg in $@; do
            argv=(${=arg})
            if eval $expr; then
                print -- $arg
            fi
        done
    fi
}

# filter using a `test` or `[[` like syntax
function tfilter {
    local expr="[[ $1 ]]"; shift
    local arg

    if (($# == 0)); then
        while read -r arg; do
            argv=(${=arg})
            if eval $expr; then
                print -- $arg
            fi
        done
    else
        IFS=
        for arg in $@; do
            argv=(${=arg})
            if eval $expr; then
                print -- $arg
            fi
        done
    fi
}

# count
function cnt {
    if (($# > 0)); then
        print -- "$#"
        return
    fi

    local counter=0
    while read _; do
        ((counter++))
    done
    print -- "$counter"
}

alias fn="function"

alias '\\'="function"

alias ret="print --"

elif [[ "$1" == "unload" ]]; then

unfunction filter tfilter afold fold amap map cmap pmap cpmap cnt

unalias fn '\\' ret

fi
