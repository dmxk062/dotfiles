#!/usr/bin/env zsh

# function patterns in zsh

# only source this, never run
if ! [[ $ZSH_EVAL_CONTEXT =~ :file$ ]]; then
    print "Extension modules are not meant to be run. Use \`+mod fun\` instead"
    exit 1
fi

if [[ "$1" == "load" ]]; then


# all of these work pretty much the same:
# argv will be set based on an element in either an array or a line in stdin, split based on IFS
# use "$@" if you want to access it all like one variable


function map {
    local expr="$1"; shift
    local arg

    if (($# == 0)); then
        while read -r arg; do
            argv=($(print -- $arg))
            eval $expr
        done
    else
        for arg in $@; do
            argv=($(print -- $arg))
            eval $expr
        done
    fi
}

# *a*rithmetic map
function amap {
    local math="print -- \$[ $1 ]"; shift
    local arg

    if (($# == 0)); then
        while read -r arg; do
            argv=($(print -- $arg))
            eval $math
        done
    else
        for arg in $@; do
            argv=($(print -- $arg))
            eval $math
        done
    fi
}

function fold {
    local expr="$1"; shift
    local arg
    local results=()

    if (($# == 0)); then
        while read -r arg; do
            argv=($(print -- $arg))
            results+=($(eval $expr))
        done
    else
        for arg in $@; do
            argv=($(print -- $arg))
            results+=($(eval $expr))
        done
    fi
    print -- $results
}

# fold with math
function afold {
    local math="print -- \$[ $1 ]"; shift
    local arg
    local result=0
    local _res

    if (($# == 0)); then
        while read -r arg; do
            argv=($(print -- $arg))
            _res=$(eval "$math")
            ((result+=_res))
        done
    else
        for arg in $@; do
            argv=($(print -- $arg))
            _res=$(eval "$math")
            ((result+=_res))
        done
    fi
    print -- $result

}

function filter {
    local expr="$1"; shift
    local arg

    if (($# == 0)); then
        while read -r arg; do
            argv=($(print -- $arg))
            if eval $expr; then
                print -- $arg
            fi
        done
    else
        for arg in $@; do
            argv=($(print -- $arg))
            if eval $expr; then
                print -- $arg
            fi
        done
    fi
}

# filter using a `test` or `[[` like syntax
function tfilter {
    local expr="[[ $1 ]]"; shift
    local arg

    if (($# == 0)); then
        while read -r arg; do
            argv=($(print -- $arg))
            if eval $expr; then
                print -- $arg
            fi
        done
    else
        IFS=
        for arg in $@; do
            argv=($(print -- $arg))
            if eval $expr; then
                print -- $arg
            fi
        done
    fi
}

# count
function cnt {
    if (($# > 0)); then
        print -- "$#"
        return
    fi

    local counter=0
    while read _; do
        ((counter++))
    done
    print -- "$counter"
}


alias fn="function"

alias '\\'="function"

alias ret="print --"

elif [[ "$1" == "unload" ]]; then

unfunction filter tfilter afold fold amap map cnt

unalias fn '\\' ret

fi
